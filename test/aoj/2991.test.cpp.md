---
data:
  _extendedDependsOn:
  - icon: ':question:'
    path: src/graphs/strongly_connected_components.cpp
    title: src/graphs/strongly_connected_components.cpp
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: true
  _pathExtension: cpp
  _verificationStatusIcon: ':x:'
  attributes:
    '*NOT_SPECIAL_COMMENTS*': ''
    PROBLEM: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2991
    links:
    - http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2991
  bundledCode: "#line 1 \"test/aoj/2991.test.cpp\"\n#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2991\"\
    \n#include <iostream>\n#line 1 \"src/graphs/strongly_connected_components.cpp\"\
    \n#include <vector>\r\n#include <algorithm>\r\n#include <stack>\r\n\r\nstruct\
    \ SCC {\r\n    int N, p;\r\n    std::vector<std::vector<int> > g, gr, g2i, t,\
    \ tr;\r\n    std::vector<bool> visited;\r\n    std::vector<int> i2g;\r\n    std::stack<int>\
    \ order;\r\n\r\n    SCC(){}\r\n    SCC(int n){init(n);}\r\n    void init(int n){\r\
    \n        N = n;\r\n        g.clear();\r\n        g.resize(N);\r\n        gr.clear();\r\
    \n        gr.resize(N);\r\n        visited.resize(N);\r\n        i2g.resize(N);\r\
    \n    }\r\n    void add_edge(int u, int v) {\r\n        g[u].emplace_back(v);\r\
    \n        gr[v].emplace_back(u);\r\n    }\r\n\r\n    void dfs(int x) {\r\n   \
    \     if (visited[x]) return;\r\n        visited[x] = true;\r\n        for (int\
    \ i : g[x]) dfs(i);\r\n        order.push(x);\r\n    }\r\n\r\n    void rdfs(int\
    \ x, int k) {\r\n        if (visited[x]) return;\r\n        visited[x] = true;\r\
    \n        i2g[x] = k;\r\n        for (int i : gr[x]) rdfs(i, k);\r\n    }\r\n\r\
    \n    void build() {\r\n        std::fill(visited.begin(), visited.end(), false);\r\
    \n        std::fill(i2g.begin(), i2g.end(), -1);\r\n        for (int i = 0; i\
    \ < N; i++) dfs(i);\r\n        p = 0;\r\n        std::fill(visited.begin(), visited.end(),\
    \ false);\r\n        while (!order.empty()) {\r\n            int idx = order.top();\r\
    \n            order.pop();\r\n            if(!visited[idx]) rdfs(idx, p++);\r\n\
    \        }\r\n        g2i.clear();\r\n        g2i.resize(p);\r\n        for(int\
    \ i=0;i<N;i++){\r\n            g2i[i2g[i]].push_back(i);\r\n        }\r\n    \
    \    t.resize(p);\r\n        tr.resize(p);\r\n        for(int i=0;i<N;i++){\r\n\
    \            for (auto &to : g[i]) {\r\n                int x = i2g[i], y = i2g[to];\r\
    \n                if (x == y) continue;\r\n                t[x].push_back(y);\r\
    \n                tr[y].push_back(x);\r\n            }\r\n        }\r\n      \
    \  for(int i=0;i<p;i++){\r\n            sort(t[i].begin(), t[i].end());\r\n  \
    \          t[i].erase(unique(t[i].begin(), t[i].end()),t[i].end());\r\n      \
    \      sort(tr[i].begin(), tr[i].end());\r\n            tr[i].erase(unique(tr[i].begin(),\
    \ tr[i].end()),tr[i].end());\r\n        }\r\n    }\r\n    int count() const {return\
    \ p;}\r\n    int operator[](int k) const {return i2g[k];}\r\n};\r\n\r\nstruct\
    \ TwoSAT {\r\n    int N;\r\n    SCC scc;\r\n    std::vector<int> v;\r\n    TwoSAT()\
    \ = default;\r\n    TwoSAT(int n):N(n),scc(n*2){}\r\n    void init(int n){\r\n\
    \        N = n;\r\n        scc.init(N*2);\r\n    }\r\n    int neg(int a){return\
    \ (a+N)%(N*2);}\r\n    void add_edge(int a, int b){\r\n        scc.add_edge(a,\
    \ b);\r\n    }\r\n    void add_if(int a, int b){\r\n        // a -> b <=> !b ->\
    \ !a\r\n        add_edge(a,b);\r\n        add_edge(neg(b), neg(a));\r\n    }\r\
    \n    void add_iff(int a, int b){\r\n        // (a <=> b) <=> a -> b and b ->\
    \ a\r\n        add_if(a, b);\r\n        add_if(b, a);\r\n    }\r\n    void add_or(int\
    \ a, int b){\r\n        // a or b <=> !a -> b and !b -> a\r\n        add_if(neg(a),\
    \ b);\r\n    }\r\n    void add_nand(int a, int b){\r\n        // a nand b <=>\
    \ a -> !b and b -> !a\r\n        add_if(a, neg(b));\r\n    }\r\n    void add_xor(int\
    \ a, int b){\r\n        add_nand(a, b);\r\n        add_or(a, b);\r\n    }\r\n\
    \    void set_true(int a){\r\n        // a <=> !a -> a\r\n        add_edge(neg(a),\
    \ a);\r\n    }\r\n    void set_false(int a){\r\n        // !a <=> a -> !a\r\n\
    \        add_edge(a, neg(a));\r\n    }\r\n    bool build(){\r\n        scc.build();\r\
    \n        bool ok = true;\r\n        for(int i=0;i<N;i++){\r\n            ok &=\
    \ scc.i2g[i] != scc.i2g[neg(i)];\r\n        }\r\n        if(ok){\r\n         \
    \   for(int i=0;i<N;i++){\r\n                v.push_back(scc[i] > scc[neg(i)]);\r\
    \n            }\r\n        }\r\n        return ok;\r\n    }\r\n    int operator[](int\
    \ k) const {return v[k];};\r\n};\r\n#line 4 \"test/aoj/2991.test.cpp\"\n\nint\
    \ main(){\n    int N, X, A, O;\n    std::cin >> N >> X >> A >> O;\n    if(X ==\
    \ 0){\n        std::cout << \"No\" << std::endl;\n        return 0;\n    }\n \
    \   TwoSAT ts(1<<(N+1));\n    for(int i=0;i<(1<<(N+1));i++){\n        ts.add_nand(i,i^X);\n\
    \        ts.add_or(i,i^X);\n    }\n    for(int i=0;i<(1<<(N+1));i++){\n      \
    \  if((i&A) == A){\n            int j = i^((1<<(N+1))-1), k = j;\n           \
    \ while(1){\n                ts.add_nand(i, k|A);\n                if(k==0) break;\n\
    \                k = (k-1)&j;\n            }\n        }\n    }\n    for(int i=0;i<(1<<(N+1));i++){\n\
    \        if((i|O) == O){\n            int j = i, k = j;\n            while(1){\n\
    \                ts.add_nand(i,k^((1<<(N+1))-1)&O);\n                if(k==0)\
    \ break;\n                k = (k-1)&j;\n            }\n        }\n    }\n    if(ts.build()){\n\
    \        std::cout << \"Yes\" << std::endl;\n        std::vector<int> ans;\n \
    \       for(int i=0;i<(1<<(N+1));i++){\n            if(ts[i]) ans.push_back(i);\n\
    \        }\n        for(int i=0;i<(1<<N);i++){\n            std::cout << ans[i]\
    \ << \" \\n\"[i==(1<<N)-1];\n        }\n    }\n    else{\n        std::cout <<\
    \ \"No\" << std::endl;\n    }\n    return 0;\n}\n"
  code: "#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2991\"\
    \n#include <iostream>\n#include \"../../src/graphs/strongly_connected_components.cpp\"\
    \n\nint main(){\n    int N, X, A, O;\n    std::cin >> N >> X >> A >> O;\n    if(X\
    \ == 0){\n        std::cout << \"No\" << std::endl;\n        return 0;\n    }\n\
    \    TwoSAT ts(1<<(N+1));\n    for(int i=0;i<(1<<(N+1));i++){\n        ts.add_nand(i,i^X);\n\
    \        ts.add_or(i,i^X);\n    }\n    for(int i=0;i<(1<<(N+1));i++){\n      \
    \  if((i&A) == A){\n            int j = i^((1<<(N+1))-1), k = j;\n           \
    \ while(1){\n                ts.add_nand(i, k|A);\n                if(k==0) break;\n\
    \                k = (k-1)&j;\n            }\n        }\n    }\n    for(int i=0;i<(1<<(N+1));i++){\n\
    \        if((i|O) == O){\n            int j = i, k = j;\n            while(1){\n\
    \                ts.add_nand(i,k^((1<<(N+1))-1)&O);\n                if(k==0)\
    \ break;\n                k = (k-1)&j;\n            }\n        }\n    }\n    if(ts.build()){\n\
    \        std::cout << \"Yes\" << std::endl;\n        std::vector<int> ans;\n \
    \       for(int i=0;i<(1<<(N+1));i++){\n            if(ts[i]) ans.push_back(i);\n\
    \        }\n        for(int i=0;i<(1<<N);i++){\n            std::cout << ans[i]\
    \ << \" \\n\"[i==(1<<N)-1];\n        }\n    }\n    else{\n        std::cout <<\
    \ \"No\" << std::endl;\n    }\n    return 0;\n}\n"
  dependsOn:
  - src/graphs/strongly_connected_components.cpp
  isVerificationFile: true
  path: test/aoj/2991.test.cpp
  requiredBy: []
  timestamp: '2022-09-13 10:36:41+09:00'
  verificationStatus: TEST_WRONG_ANSWER
  verifiedWith: []
documentation_of: test/aoj/2991.test.cpp
layout: document
redirect_from:
- /verify/test/aoj/2991.test.cpp
- /verify/test/aoj/2991.test.cpp.html
title: test/aoj/2991.test.cpp
---
